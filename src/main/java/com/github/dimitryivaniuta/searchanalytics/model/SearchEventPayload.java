package com.github.dimitryivaniuta.searchanalytics.model;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

/**
 * Canonical payload of a search event as published to Kafka.
 *
 * This is what the frontend / other services send to the "search-events" topic.
 * The analytics-service consumes it and:
 *  - writes a raw copy into raw_search_events
 *  - updates daily_query_stats
 *  - optionally emits outbox events
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonIgnoreProperties(ignoreUnknown = true)
public class SearchEventPayload {

    /**
     * Unique event id for idempotency / correlation.
     * Often a UUID generated by the producer.
     */
    private String eventId;

    /**
     * Authenticated user id, if known.
     * If user is anonymous, see anonymousId.
     */
    private String userId;

    /**
     * Anonymous identifier (cookie / device id) when userId is not present.
     */
    private String anonymousId;

    /**
     * Frontend session id (e.g. tab/session id).
     */
    private String sessionId;

    /**
     * Raw search query string entered by the user.
     * This is the main dimension we aggregate in daily_query_stats.
     */
    private String query;

    /**
     * 2-letter ISO country code, e.g. "PL", "DE".
     */
    private String country;

    /**
     * IETF language tag, e.g. "en-US", "pl-PL".
     */
    private String locale;

    /**
     * Device type, e.g. "desktop", "mobile", "tablet".
     */
    private String deviceType;

    /**
     * Platform / client application: "web", "ios", "android", "backend".
     */
    private String platform;

    /**
     * Where the search originated: "search-bar", "filters-panel", "homepage".
     */
    private String source;

    /**
     * Optional IP address string for geo / security analytics.
     */
    private String ipAddress;

    /**
     * When the search action happened on the client (business time).
     * Used for day-bucketing in daily_query_stats.
     */
    @JsonFormat(shape = JsonFormat.Shape.STRING)
    private Instant occurredAt;

    /**
     * When producer sent the event (producer server time).
     */
    @JsonFormat(shape = JsonFormat.Shape.STRING)
    private Instant sentAt;

    /**
     * Optional contextual filters applied with the search.
     */
    private Filters filters;

    /**
     * Convenience: true if payload has minimum data required to be aggregated.
     * (You can use this in listener before touching DB.)
     */
    public boolean isValidForAggregation() {
        return query != null && !query.isBlank() && occurredAt != null;
    }

    /**
     * Nested object for structured filter info.
     * Extend freely as your domain grows.
     */
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class Filters {

        /**
         * High-level category (e.g. "electronics", "cars").
         */
        private String category;

        /**
         * Optional sub-category (e.g. "laptop", "sedan").
         */
        private String subCategory;

        /**
         * Zero-based page index requested.
         */
        private Integer page;

        /**
         * Page size requested.
         */
        private Integer pageSize;

        /**
         * Sort field (e.g. "price", "relevance").
         */
        private String sortBy;

        /**
         * Sort direction: "asc" / "desc".
         */
        private String sortDirection;

        /**
         * Arbitrary JSON-encoded extra filters (for quick extension
         * without schema changes â€“ can be exploded later if needed).
         *
         * Example: {"brand":["Apple","Dell"],"priceFrom":1000,"priceTo":2000}
         */
        private String extraJson;
    }
}
